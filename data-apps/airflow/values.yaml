---
airflow:
  uid: 50000
  gid: 0
  airflowHome: /opt/airflow
  defaultAirflowRepository: apache/airflow
  defaultAirflowTag: "2.4.3"
  airflowVersion: "2.4.3"
  ingress:
    web:
      enabled: false
      path: "/"
      pathType: "ImplementationSpecific"
      tls:
        enabled: false
    flower:
      enabled: false
      path: "/"
      pathType: "ImplementationSpecific"
      host: ""
      ingressClassName: ""
      tls:
        enabled: false
        secretName: ""
  networkPolicies:
    enabled: false
  airflowLocalSettings: |-
    {{- if semverCompare ">=2.2.0" .Values.airflowVersion }}
    {{- if not (or .Values.webserverSecretKey .Values.webserverSecretKeySecretName) }}
    from airflow.www.utils import UIAlert
    DASHBOARD_UIALERTS = [
      UIAlert(
        'Usage of a dynamic webserver secret key detected. We recommend a static webserver secret key instead.'
        ' See the <a href='
        'Helm Chart Production Guide</a> for more details.',
        category="warning",
        roles=["Admin"],
        html=True,
      )
    ]
    {{- end }}
    {{- end }}
  rbac:
    create: true
    createSCCRoleBinding: false
  executor: "CeleryExecutor"
  allowPodLaunching: true
  enableBuiltInSecretEnvVars:
    AIRFLOW__CORE__FERNET_KEY: true
    AIRFLOW__CORE__SQL_ALCHEMY_CONN: true
    AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: true
    AIRFLOW_CONN_AIRFLOW_DB: true
    AIRFLOW__WEBSERVER__SECRET_KEY: true
    AIRFLOW__CELERY__CELERY_RESULT_BACKEND: true
    AIRFLOW__CELERY__RESULT_BACKEND: true
    AIRFLOW__CELERY__BROKER_URL: true
    AIRFLOW__ELASTICSEARCH__HOST: true
    AIRFLOW__ELASTICSEARCH__ELASTICSEARCH_HOST: true
  extraEnv: ~
  extraEnvFrom: ~
  data:
    metadataSecretName: ~
    resultBackendSecretName: ~
    brokerUrlSecretName: ~
    metadataConnection:
      user: postgres
      pass: postgres
      protocol: postgresql
      host: ~
      port: 5432
      db: postgres
      sslmode: disable
    resultBackendConnection: ~
    brokerUrl: ~
  fernetKey: ~
  fernetKeySecretName: ~
  webserverSecretKey: ~
  webserverSecretKeySecretName: ~
  kerberos:
    enabled: false
    ccacheMountPath: /var/kerberos-ccache
    ccacheFileName: cache
    configPath: /etc/krb5.conf
    keytabBase64Content: ~
    keytabPath: /etc/airflow.keytab
    principal: airflow@FOO.COM
    reinitFrequency: 3600
    config: |
      [logging]
      default = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_libs.log"
      kdc = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_kdc.log"
      admin_server = "FILE:{{ template "airflow_logs_no_quote" . }}/kadmind.log"
      [libdefaults]
      default_realm = FOO.COM
      ticket_lifetime = 10h
      renew_lifetime = 7d
      forwardable = true
      [realms]
      FOO.COM = {
        kdc = kdc-server.foo.com
        admin_server = admin_server.foo.com
      }
  workers:
    replicas: 1
    revisionHistoryLimit: ~
    command: ~
    args:
      - "bash"
      - "-c"
      - |-
        exec \
        airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery worker" "worker" }}
    livenessProbe:
      enabled: true
      initialDelaySeconds: 10
      timeoutSeconds: 20
      failureThreshold: 5
      periodSeconds: 60
      command: ~
    updateStrategy: ~
    strategy:
      rollingUpdate:
        maxSurge: "100%"
        maxUnavailable: "50%"
    serviceAccount:
      create: true
      name: ~
    keda:
      enabled: false
      pollingInterval: 5
      cooldownPeriod: 30
      minReplicaCount: 0
      maxReplicaCount: 10
    persistence:
      enabled: true
      size: 100Gi
      storageClassName:
      fixPermissions: false
    kerberosSidecar:
      enabled: false
    terminationGracePeriodSeconds: 600
    safeToEvict: true
    priorityClassName: ~
    logGroomerSidecar:
      enabled: true
      command: ~
      args: ["bash", "/clean-logs"]
      retentionDays: 15
    waitForMigrations:
      enabled: true
  scheduler:
    livenessProbe:
      initialDelaySeconds: 10
      timeoutSeconds: 20
      failureThreshold: 5
      periodSeconds: 60
      command: ~
    replicas: 1
    revisionHistoryLimit: ~
    command: ~
    args: ["bash", "-c", "exec airflow scheduler"]
    updateStrategy: ~
    strategy: ~
    serviceAccount:
      create: true
      name: ~
    podDisruptionBudget:
      enabled: false
      config:
        maxUnavailable: 1
    safeToEvict: true
    priorityClassName: ~
    logGroomerSidecar:
      enabled: true
      command: ~
      args: ["bash", "/clean-logs"]
      retentionDays: 15
    waitForMigrations:
      enabled: true
  createUserJob:
    command: ~
    args:
      - "bash"
      - "-c"
      - |-
        exec \
        airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "users create" "create_user" }} "$@"
      - --
      - "-r"
      - "{{ .Values.webserver.defaultUser.role }}"
      - "-u"
      - "{{ .Values.webserver.defaultUser.username }}"
      - "-e"
      - "{{ .Values.webserver.defaultUser.email }}"
      - "-f"
      - "{{ .Values.webserver.defaultUser.firstName }}"
      - "-l"
      - "{{ .Values.webserver.defaultUser.lastName }}"
      - "-p"
      - "{{ .Values.webserver.defaultUser.password }}"
    serviceAccount:
      create: true
      name: ~
    useHelmHooks: true
    applyCustomEnv: true
  migrateDatabaseJob:
    enabled: true
    command: ~
    args:
      - "bash"
      - "-c"
      - |-
        exec \
        airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "db upgrade" "upgradedb" }}
    serviceAccount:
      create: true
      name: ~
    useHelmHooks: true
    applyCustomEnv: true
  webserver:
    allowPodLogReading: true
    livenessProbe:
      initialDelaySeconds: 15
      timeoutSeconds: 30
      failureThreshold: 20
      periodSeconds: 5
      scheme: HTTP
    readinessProbe:
      initialDelaySeconds: 15
      timeoutSeconds: 30
      failureThreshold: 20
      periodSeconds: 5
      scheme: HTTP
    replicas: 1
    revisionHistoryLimit: ~
    command: ~
    args: ["bash", "-c", "exec airflow webserver"]
    serviceAccount:
      create: true
      name: ~
    podDisruptionBudget:
      enabled: false
      config:
        maxUnavailable: 1
    strategy: ~
    networkPolicy:
      ingress:
        ports:
          - port: "{{ .Values.ports.airflowUI }}"
    defaultUser:
      enabled: true
      role: Admin
      username: admin
      email: admin@example.com
      firstName: admin
      lastName: user
      password: admin
    webserverConfig: ~
    service:
      type: ClusterIP
      ports:
        - name: airflow-ui
          port: "{{ .Values.ports.airflowUI }}"
      loadBalancerIP: ~
    priorityClassName: ~
    waitForMigrations:
      enabled: true
  triggerer:
    enabled: true
    replicas: 1
    revisionHistoryLimit: ~
    command: ~
    args: ["bash", "-c", "exec airflow triggerer"]
    strategy:
      rollingUpdate:
        maxSurge: "100%"
        maxUnavailable: "50%"
    livenessProbe:
      initialDelaySeconds: 10
      timeoutSeconds: 20
      failureThreshold: 5
      periodSeconds: 60
      command: ~
    serviceAccount:
      create: true
      name: ~
    terminationGracePeriodSeconds: 60
    safeToEvict: true
    priorityClassName: ~
    waitForMigrations:
      enabled: true
  dagProcessor:
    enabled: false
    replicas: 1
    revisionHistoryLimit: ~
    command: ~
    args: ["bash", "-c", "exec airflow dag-processor"]
    strategy:
      rollingUpdate:
        maxSurge: "100%"
        maxUnavailable: "50%"
    livenessProbe:
      initialDelaySeconds: 10
      timeoutSeconds: 20
      failureThreshold: 5
      periodSeconds: 60
      command: ~
    serviceAccount:
      create: true
      name: ~
    terminationGracePeriodSeconds: 60
    safeToEvict: true
    priorityClassName: ~
    waitForMigrations:
      enabled: true
  flower:
    enabled: false
    revisionHistoryLimit: ~
    command: ~
    args:
      - "bash"
      - "-c"
      - |-
        exec \
        airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery flower" "flower" }}
    networkPolicy:
      ingress:
        ports:
          - port: "{{ .Values.ports.flowerUI }}"
    serviceAccount:
      create: true
      name: ~
    secretName: ~
    username: ~
    password: ~
    service:
      type: ClusterIP
      ports:
        - name: flower-ui
          port: "{{ .Values.ports.flowerUI }}"
      loadBalancerIP: ~
    priorityClassName: ~
  statsd:
    enabled: true
    revisionHistoryLimit: ~
    serviceAccount:
      create: true
      name: ~
    uid: 65534
    service:
    priorityClassName: ~
  pgbouncer:
    enabled: false
    replicas: 1
    revisionHistoryLimit: ~
    command: ["pgbouncer", "-u", "nobody", "/etc/pgbouncer/pgbouncer.ini"]
    args: ~
    auth_type: md5
    auth_file: /etc/pgbouncer/users.txt
    serviceAccount:
      create: true
      name: ~
    metadataPoolSize: 10
    resultBackendPoolSize: 5
    maxClientConn: 100
    configSecretName: ~
    podDisruptionBudget:
      enabled: false
      config:
        maxUnavailable: 1
    service:
    verbose: 0
    logDisconnections: 0
    logConnections: 0
    sslmode: "prefer"
    ciphers: "normal"
    ssl:
      ca: ~
      cert: ~
      key: ~
    extraIniMetadata: ~
    extraIniResultBackend: ~
    extraIni: ~
    priorityClassName: ~
    uid: 65534
    metricsExporterSidecar:
      sslmode: "disable"
  redis:
    enabled: true
    terminationGracePeriodSeconds: 600
    serviceAccount:
      create: true
      name: ~
    persistence:
      enabled: true
      size: 1Gi
      storageClassName:
    passwordSecretName: ~
    password: ~
    safeToEvict: true
    uid: 0
  registry:
    secretName: ~
  elasticsearch:
    enabled: false
    secretName: ~
  ports:
    flowerUI: 5555
    airflowUI: 8080
    workerLogs: 8793
    redisDB: 6379
    statsdIngest: 9125
    statsdScrape: 9102
    pgbouncer: 6543
    pgbouncerScrape: 9127
  cleanup:
    enabled: false
    schedule: "*/15 * * * *"
    command: ~
    args:
      [
        "bash",
        "-c",
        "exec airflow kubernetes cleanup-pods --namespace={{ .Release.Namespace }}",
      ]
    serviceAccount:
      create: true
  postgresql:
    enabled: true
    postgresqlPassword: postgres
    postgresqlUsername: postgres
  config:
    core:
      dags_folder: '{{ include "airflow_dags" . }}'
      load_examples: "False"
      executor: "{{ .Values.executor }}"
      colored_console_log: "False"
      remote_logging: '{{- ternary "True" "False" .Values.elasticsearch.enabled }}'
    logging:
      remote_logging: '{{- ternary "True" "False" .Values.elasticsearch.enabled }}'
      colored_console_log: "False"
    metrics:
      statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
      statsd_port: 9125
      statsd_prefix: airflow
      statsd_host: '{{ printf "%s-statsd" .Release.Name }}'
    webserver:
      enable_proxy_fix: "True"
      rbac: "True"
    celery:
      flower_url_prefix: "{{ .Values.ingress.flower.path }}"
      worker_concurrency: 16
    scheduler:
      standalone_dag_processor: '{{ ternary "True" "False" .Values.dagProcessor.enabled }}'
      statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
      statsd_port: 9125
      statsd_prefix: airflow
      statsd_host: '{{ printf "%s-statsd" .Release.Name }}'
      run_duration: 41460
    elasticsearch:
      json_format: "True"
      log_id_template: "{dag_id}_{task_id}_{execution_date}_{try_number}"
    elasticsearch_configs:
      max_retries: 3
      timeout: 30
      retry_timeout: "True"
    kerberos:
      keytab: "{{ .Values.kerberos.keytabPath }}"
      reinit_frequency: "{{ .Values.kerberos.reinitFrequency }}"
      principal: "{{ .Values.kerberos.principal }}"
      ccache: "{{ .Values.kerberos.ccacheMountPath }}/{{ .Values.kerberos.ccacheFileName }}"
    celery_kubernetes_executor:
      kubernetes_queue: "kubernetes"
    kubernetes:
      namespace: "{{ .Release.Namespace }}"
      airflow_configmap: '{{ include "airflow_config" . }}'
      airflow_local_settings_configmap: '{{ include "airflow_config" . }}'
      pod_template_file: '{{ include "airflow_pod_template_file" . }}/pod_template_file.yaml'
      worker_container_repository: "{{ .Values.images.airflow.repository | default .Values.defaultAirflowRepository }}"
      worker_container_tag: "{{ .Values.images.airflow.tag | default .Values.defaultAirflowTag }}"
      multi_namespace_mode: '{{ ternary "True" "False" .Values.multiNamespaceMode }}'
  multiNamespaceMode: false
  podTemplate: ~
  dags:
    persistence:
      enabled: false
      size: 1Gi
      storageClassName:
      accessMode: ReadWriteOnce
      existingClaim:
      subPath: ~
    gitSync:
      enabled: true
      repo: https://github.com/apache/airflow.git
      branch: v2-2-stable
      rev: HEAD
      depth: 1
      maxFailures: 0
      subPath: "tests/dags"
      wait: 5
      containerName: git-sync
      uid: 65533
  logs:
    persistence:
      enabled: false
      size: 10Gi
      storageClassName:
      existingClaim:
